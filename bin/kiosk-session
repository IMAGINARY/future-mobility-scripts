#!/bin/bash

PIDS=""
function finish {
  EXIT_CODE=$?
  kill $PIDS >/dev/null 2>&1
  exit $EXIT_CODE
}
trap finish SIGINT SIGTERM EXIT


# Save current environment
EXPORTED_ENV=$(export)

refresh_config() {
    # Source system wide default values
    SYSTEM_DEFAULTS_FILE="/etc/default/kiosk"
    [ -r "$SYSTEM_DEFAULTS_FILE" ] && . "$SYSTEM_DEFAULTS_FILE" 

    # Source user-defined default values
    CONFIG_DIR="${XDG_CONFIG_HOME:-"$HOME/.config"}/kiosk"
    USER_DEFAULTS_FILE="${CONFIG_DIR}/default"
    [ -r "$USER_DEFAULTS_FILE" ] && . "$USER_DEFAULTS_FILE" 

    # Restore previous environment such that it takes precendence over the config files
    eval "$EXPORTED_ENV"
}
refresh_config

# For some reason, the X server doesn't seem to be fully ready.
# It is possible to launch applications, but there are problems with framebuffer scaling and window positioning
sleep 1

# Disable screen saver
xset s noblank
xset s off

# Apply screen layout script, if defined
if [ -n "$INIT_SCREEN_LAYOUT" ]; then
    echo "Running screen layout script: $INIT_SCREEN_LAYOUT"
    ( bash -c "exec $INIT_SCREEN_LAYOUT"; sleep 1; bash -c "exec $INIT_SCREEN_LAYOUT" ) &
    PID_CMD=$!
    PIDS="$PIDS $PID_CMD"
    wait $PID_CMD
else
    >&2 echo "Skipping screen layout setting: No screen layout script found."
fi

do_map_touch_screen_devices_to_outputs() {
    local LENGTH NUM i DEVICE_INDEX OUTPUT_INDEX
    LENGTH="${#TOUCH_SCREEN_OUTPUT_MAP[@]}"
    NUM="$(( ${#TOUCH_SCREEN_OUTPUT_MAP[@]} / 2 ))"

    if [[ "$(( $LENGTH % 2 ))" != "0" ]]; then
        echo "TOUCH_SCREEN_OUTPUT_MAP has uneven length. Aborting."
        exit 1
    fi

    for ((i=0; i < "$NUM"; i++))
    do
        DEVICE_INDEX=$(( 2 * "${i}" + 0 ))
        OUTPUT_INDEX=$(( 2 * "${i}" + 1 ))
        DEVICE="${TOUCH_SCREEN_OUTPUT_MAP[$DEVICE_INDEX]}"
        OUTPUT="${TOUCH_SCREEN_OUTPUT_MAP[$OUTPUT_INDEX]}"
        echo "Mapping touch-screen device ${DEVICE} to output ${OUTPUT}."
        map-input-device-node-to-output "${DEVICE}" "${OUTPUT}"
    done
}

do_loop_map_touch_screen_devices_to_outputs() {
    local TOUCH_SCREEN_OUTPUT_MAP_OLD XINPUT_OUTPUT_BEFORE XINPUT_OUTPUT_AFTER DISPLAY_OUTPUT_OVERRIDE RET
    TOUCH_SCREEN_OUTPUT_MAP_OLD=false
    DISPLAY_OUTPUT_OVERRIDE=true
    while true; do
        refresh_config
        if [ -n "$TOUCH_SCREEN_OUTPUT_MAP" ]; then
            XINPUT_OUTPUT_BEFORE=$(xinput list --long; xinput list --id-only | xargs -I {} xinput list-props "{}")
            OUTPUT=$(do_map_touch_screen_devices_to_outputs 2>&1)
            RET=$?
            XINPUT_OUTPUT_AFTER=$(xinput list --long; xinput list --id-only | xargs -I {} xinput list-props "{}")

            if [[ "${RET}" != 0 || "${DISPLAY_OUTPUT_OVERRIDE}" == true || "${XINPUT_OUTPUT_BEFORE}" != "${XINPUT_OUTPUT_AFTER}" ]]; then
                DISPLAY_OUTPUT_OVERRIDE=false
                echo "${OUTPUT}"
            fi
            TOUCH_SCREEN_OUTPUT_MAP_OLD=("${TOUCH_SCREEN_OUTPUT_MAP[@]}")
        else
            DISPLAY_OUTPUT_OVERRIDE=true

            # Only print this message if the map has changed
            if [[ "${TOUCH_SCREEN_OUTPUT_MAP[*]}" != "${TOUCH_SCREEN_OUTPUT_MAP_OLD[*]}" ]]; then
                >&2 echo "Skipping mapping of touch-screen devices to X11 outputs: TOUCH_SCREEN_OUTPUT_MAP undefined."
            fi
        fi
        sleep 5
    done
}

# Apply touch-screen device mapping repeatedly in the background
(do_loop_map_touch_screen_devices_to_outputs) &
PIDS="$PIDS $!"

exec_exhibit() {
    local CMD=()
    [ "$HIDE_CURSOR" = true ] && CMD+=( hidecursor )
    [ "$LOOP_MODE" = true ] && CMD+=( repeat-exhibit )
    CMD+=( exhibit-default )
    exec "${CMD[@]}"
}

# Set up the default environment for the default exhibit and run it
( ! init-default --test || init-default ) \
    && exhibit-default --test \
    && (exec_exhibit &)
PIDS="$PIDS $!"

# Run a compositor in the background for dealing with vsync and tearing
# Should be done after screen setup (e.g. in init-* scripts)
picom --backend=glx --use-damage --vsync &
PIDS="$PIDS $!"

# Set wallpaper
# Should be done after screen setup (e.g. in init-* scripts)
feh --bg-max /opt/kiosk-scripts/assets/wallpaper.png --image-bg "$(< /opt/kiosk-scripts/assets/wallpaper-bg-color.txt)" &
PIDS="$PIDS $!"

# Keep the session alive until its explicitly killed from outside
env sleep infinity &
PID_SLEEP=$!
PIDS="$PIDS $PID_SLEEP"

wait $PID_SLEEP
